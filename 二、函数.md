[TOC]
## 二、函数

### 1 常规函数

```python

    def my_func(message)->str:
        '''
        示例函数说明
        '''
        pass
        print('Got a message: {}'.format(message))

    # 调用函数 my_func()
    my_func('Hello World')
    # 输出 Got a message: Hello World
    def 函数名(参数列表):
        //实现特定功能的多行代码
        [return [返回值]]
    print(my_func.__doc__)
    #    示例函数说明
    

```

- def 是函数的声明；
- my_func是函数的名称；
- ()里面的message是函数的参数，参数列表；
- ->str 是说明传递的对象是str类型，作为注释(增加元信息)
- '''  注释'''函数的注释说明文档，可用help()或  __ doc __ 属性查看说明文档(’‘’   ‘’‘   与  ""  与  ''  都可以)
- 空语句pass 是关键字，用来让解释器跳过此处，什么也不做。在程序需要占一个位置或者放一条语句但又不希望这条语句做任何事情，此时就可用pass语句来实现，比注释更加优雅。
-  [return [返回值]或yield] ：可选的内容，根据实情可有可无。不带return相当于返回None。

#### 1.1 函数传入参数(实参、形参、可变对象与不可变对象)

- 形式参数：在定义函数时在函数名后面括号中的参数就是形式参数，例如def demo(obj)中obj就是形式参数
- 实际参数：在调用函数时在函数名后面括号中实际调用者给的函数的参数就是实际参数

如同剧本中的角色相当于形参，而实际参演的演员本身就相当于实参

- 传不可变对象(immutable)：数字类型(int,float,bool)、字符串、元组和自定义类的对象(值传递)
- 传可变对象(mutable): list、dict、set(引用传递)

```python
def change(a):
    print(id(a))   # 指向的是同一个对象
    a=10
    print(id(a))   # 一个新对象
 
a=1
print(id(a))
change(a)
#4379369136
#4379369136
#4379369424
print(id(a))
#4379369136
```

在调用函数前后，形参和实参指向的时同一个对象(对象id相同)，在函数内部想改形参后，形参指向的是不同的id

但是并没有更改原先的a的值。所以在传不可变对象后，不可变对象当然不可变。在实参传入形参时只是传入了一个参数的复制品不影响参数本身。

```python
def changeme( mylist ):
   "修改传入的列表"
   mylist.append([1,2,3,4])
   print ("函数内取值: ", mylist)
   return
 
# 调用changeme函数
mylist = [10,20,30]
changeme( mylist )
print ("函数外取值: ", mylist)
#函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
#函数外取值:  [10, 20, 30, [1, 2, 3, 4]]
```

传入函数前与传入函数后的对象仍是同一个引用，所以在传可变对象后，可变对象是可变的。

#### 1.2 参数类型

位置参数、关键字参数、默认参数、不定长参数。

##### 1.2.1 位置参数(positional argument)

位置参数有时也称为必备参数，正确的顺序(数量与位置)将实参传入形参中

```python
def printme( str ):
   "打印任何传入的字符串"
   print (str)
   return

# 调用 printme 函数，不加参数会报错
printme('haah','ahaha')
printme()
#参数给多了 TypeError: printme() takes 1 positional argument but 2 were given
#参数给少或没有 TypeError: printme() missing 1 required positional argument: 'str'
```

自然数据类型或者错位也是不行的

##### 1.2.2 关键字参数(keyword argument)

使用关键字参数允许函数调用时参数的顺序与声明时不一致

```python
def dis_str(str1,str2):
    print("str1:",str1)
    print("str2:",str2)
    
dis_str(str2='aaa', str1='bbb')
#str1:bbb
#str2:aaa
```

首先是应该满足位置参数中数量上的条件，顺序可以取决于关键字。

但是在混合使用位置参数和关键字参数时：位置参数必须在关键字之前

##### 1.2.3 默认参数

在调用函数时如若没有传递相应的参数，则会使用默认参数，特别的指定有默认值的形式参数必须在所有没有默认值参数的最后,且指向不变对象，形同字典的键值对。

```python
def printinfo( name, age = 18 ):
   "打印任何传入的字符串"
   print ("名字: ", name)
   print ("年龄: ", age)
   return
 
#调用printinfo函数
printinfo( age=22, name="wy" )
print ("------------------------")
printinfo( name="wy" )
```

在调用自定义函数可以清楚知道默认值，在使用内置函数或第三方提供的函数时，

可使用"函数名.__ __defaults__ __"查看函数的默认值参数的当前值，其返回值是一个元组

##### 1.2.4  **不定长参数**

- *arg 会把多出来的位置参数转化为tuple，一个 *参数只能出现在函数定义中最后一个位置参数后面
-  ** kwarg  将关键字参数转化为dict， **参数只能出现在最后一个参数
- *参数或者单个 * 后面添加的不是位置参数，即在使用含 *的函数时定义或调用时必有一个=号即关键参数或者默认参数

1.  *arg 支持多个位置参数输入,且将多位位置参数转化为一个元组，

   注意：如果这里只输入一个元组则虽然arg变量是一个元组类型但是表示的却是((),)即元组的序列0即

   arg[0]>>>输入的元组

```python
def sum(*arg):
    res = 0
    if len(arg) > 1:
        for _ in arg:
            res += _
        print(res)
    else:
        a = arg[0]
        for _ in a:
            res += _
        print(res)

        
s = (3,5,7,9)
sum(s)
sum(3,5,7,8)
#24
#23
```

下面是*逆向参数输入：

```python
def sum(a, b, c):
    return a + b + c

a = [1, 2, 3]

# the * unpack list a 
print sum(*a)
>> 6
```



2. **kwarg 参数，可接收任意数量的关键字参数，将接收到的参数转化为字典,

注意：这里必然不能出现一个字典作为关键字参数，字典的键为不可变数据类型。

```python
def test(*books, num, **scores):
    print('books:', books)
    print('num:', num)
    print('scores:', scores)
    
test('python', 'java', 'c', num=3, py=90, ja=80)

```

下面是**的逆向参数输入：

```python
def sum(a, b, c):
    return a + b + c

a = {'a': 1, 'b': 2, 'c': 3}

# the ** unpack dict a
print sum(**a)
>> 6
```

3. 在python3.8中新增了一个函数形参语法/用来指明函数形参必须使用位置参数，不能使用关键字参数的形式。

例如：

```python
def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
    
    
    
#正确的使用方法是：
f(10, 20, 30, d=40, e=50, f=60)#a和b必须使用位置参数，c与d可以是位置也可是关键字，e与f必须使用关键字
```

#### 1.3 函数变量作用域

L(local)-->E(Enclosing)-->G(Global)-->B(Built-in)

- 局部变量(enclosing)在函数内部定义的变量，一旦函数执行完毕，局部变量就会被回收，无法访问；
- 全局变量(Global)定义在整个文件层次上的，函数内部可以访问如果想改变全局变量的值需要在变量前面加上**global**这个声明；如果函数内部局部变量和全局变量同名，那局部变量就会覆盖全局变量但肯定不会改变全局变量的值。
- 内部变量来(local)在自定义的函数内部如果有嵌套的函数，同样的内部函数可以访问外部函数定义的变量自然无法修改，如若要修改必须加上**nonlocal**这个关键字，也同样的如若内部变量与外部变量同名也会覆盖外部变量自然也是修改不了的

#### 1.4 闭包(closure)

闭包和嵌套函数类似，不同的是这里外部函数返回的是一个函数而不是一个具体的值，返回的函数通常赋于一个变量，这个变量可以和后面被继续执行调用。

```python

def nth_power(exponent):
    def exponent_of(base):
        return base ** exponent
    return exponent_of # 返回值是exponent_of函数

square = nth_power(2) # 计算一个数的平方
cube = nth_power(3) # 计算一个数的立方 
square
# 输出
<function __main__.nth_power.<locals>.exponent(base)>

cube
# 输出
<function __main__.nth_power.<locals>.exponent(base)>

print(square(2))  # 计算2的平方
print(cube(2)) # 计算2的立方
# 输出
4 # 2^2
8 # 2^3
```

```python
#下面的函数看上去甚至比上面看着更简洁
def nth_power_rewrite(base, exponent):
    return base ** exponent

```

```python

# 不适用闭包
res1 = nth_power_rewrite(base1, 2)
res2 = nth_power_rewrite(base2, 2)
res3 = nth_power_rewrite(base3, 2)
...

# 使用闭包
square = nth_power(2)
res1 = square(base1)
res2 = square(base2)
res3 = square(base3)
...
```

但是在使用闭包形式时，可以让每次调用函数都可以少输入一个参数，在函数开头需要做一些额外工作而有需要多次调用这个函数时，将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要的开销提高程序的运行效率

#### 1.5 return 及返回多值

函数中可以同时包含多个return语句但是最终真正执行的最多只有一个且一旦执行函数运行就会立刻结束。

```python
#使用object返回多值
class Test:
    def __init__(self):
        self.str = "hello world!"
        self.x = 20  
# 返回一个对象
def fun():
    return Test()
t = fun() 
print(t.str)
print(t.x)
#hello world!
#20
```

```
#使用列表
def fun():
	str = 'hello'
	x = 20
	return [str,x];
	
list = fun()
print(list)
# ['hello', 20]
```

```
#使用元组
def fun():
	str = '你好'
	x = 2020
	return str,x;
	
str,x = fun()
print(str)
print(x)
#你好
#2020
```

```
#使用字典
def fun():
	d = dict()
	d['name'] = '张三'
	d['age'] = 22
	return d

d = fun()
print(d)
#{'name': '张三', 'age': 22}
```

### 2 匿名函数

python 使用lambda 来创建匿名函数，所谓匿名即不再使用def语句这样标准的形式定义一个函数

#### 2.1 lambda 作用在列表与函数内部

lambda argument1, argument2,... argumentN : expression，

lambda是一个表达式(expression)，并不是一个语句(statement)，表达式就是用一系列公式去表达一个东西，而语句则是利用内置函数条件语句等完成某些功能

```python
#通用匿名函数格式
square = lambda x: x**2
square(3)
# 9  注意：每个匿名函数都可以写成常规函数

#lambda可以用在一些常规函数def不能用的地方，比如在列表内部，常规函数却不能
print([(lambda x: x*x)(x) for x in range(10)])
#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

#lambda表达式典型的使用场景是排序或数据reduce等如作用在sort、map、filter等函数的参数：

l = [(1, 20), (3, 0), (9, 10), (2, -1)]
l.sort(key=lambda x: x[1]) # 按列表中元组的第二个元素排序
print(l)
# [(2, -1), (3, 0), (9, 10), (1, 20)]
sorted(d.items(), key=lambda x: x[1], reverse=True)；#字典中按照值排序且倒序(从高到低)

#map(function,iterable)的第一个函数是函数对象其二是一个可以遍历的集合，它表示对iterable的每一个元素都运用function这个函数
squared = map(lambda x: x**2, [1, 2, 3, 4, 5])
print(list(squared))
#[1, 4, 9, 16, 25]

#filter(function, iterable) 函数，它和 map 函数类似，function 同样表示一个函数对象。filter() 函数表示对 iterable 中的每个元素，都使用 function 判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合
new_list = filter(lambda x: x % 2 ==0,[1,2,3,4,5,6])
print(list(new_list))
```

#### 2.2 lambda中关于自由变量通常会错的两个例子

lambda的表达式中的argument1(通常用x)是一个自由变量，是在运行时绑定值，而不是定义时绑定，即x的值时执行时的值

```python
x = 10
a = lambda y: x + y
x = 20
b = lambda y: x + y
print(a(10))
print(b(10))
```

注意！！：如果没有运行这段代码你非常可能会认为结果是20和30，其实实际结果是30与30，就是因为在运行涉及到lambda里的变量时变量取决在运行前最后得到的x的值。

```python
#想让某个匿名函数在定义时就捕获到值，可以将那个参数值定义成默认参数即可

x = 10
a = lambda y, x=x: x + y
x = 20
b = lambda y, x=x: x + y
print(a(10))
print(b(10))
```



```python
#!!!!!!!!!!!!!
#通过在一个循环或列表推导中创建一个lambda表达式列表，并期望函数能在定义时就记住每次的迭代值
func = [lambda x: x+n for n in range(5)]

def f(x):
    for _ in x:
        print(_(0))
f(func)
#实际效果是运行是n的值为迭代的最后一个值????????
```

```python
#修改如下即将参数值定义成默认参数，lambda函数在定义时就能绑定到值
func = [lambda x,n=n: x+n for n in range(5)]

def f(x):
    for _ in x:
        print(_(0))
f(func)
```

### 3 魔法函数



### 4 内置函数





























