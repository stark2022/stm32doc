[TOC]
##  一 、基本数据类型
### 1.数值型
数据皆是对象，int、float、bool都是单个元素。
#### 1.1 integer(int)整数
在python3中的整数没有上限（只要不超出内存空间）。
##### 1.1.1numpy中的整数
numpy由C语言实现所以用的是C的规则
```
import numpy as np
a = nparange(2)
print(type(a[0]))
#<class 'numpy.int32'>
```
是int32，表示范围在 -2147483648 ~ 2147483647
**NumPy 数据类型：**
![201991182511352](E:\chrome\201991182511352.jpg)
在numpy 中解决整数溢出问题，可以通过指定dtype的方式：

```
import numpy as np
q = [100000]
w = [500000]
# 一个溢出的例子：
a = np.array(q)
b = np.array(w)
print(a*b) # 产生溢出，结果是个奇怪的数值
# 一个解决的例子：
c = np.array(q, dtype='int64')
d = np.array(w, dtype='int64')
print(c*d) # 没有溢出：[50000000000]
```
##### 1.1.2  整数太大而溢出

```python
print(245.0 ** 1000)
# OverflowError: (34, 'Result too large')
```



#### 1.2 float浮点数
带有小数点的就是**float浮点数**

```
0xa5   # 165还是整数各进制只有带小数才能是浮点数
3.14159e3   #3141.59 只要写成指数形式就是浮点数
print(type(14E3))   # 14000   <class 'float'>
```
0.1转换成二进制数后无法精确到等于十进制数的0.1
```
0.1(10)=0.00011001100110011...(2)
```
所有支持浮点数运算的编程语言中都有这样的问题,存储的二进制位数超过了计算机存储位数的最大值，其后续位数会被舍弃（舍弃的原则是“0 舍 1 入”）
```
a = 3.5 + 0.1
print(a)  #3.6
b = 0.35 + 0.1
print(b)  #0.44999999999999996
```
这里使用decimal模块(意思为十进制，这个模块提供了十进制浮点运算支持)
```python
import decimal
a = decimal.Decimal("0.35")
b = decimal.Decimal("0.1")
print(a+b)   # 0.45
```
#### 1.3    /,  //,   **,   %,  科学计数法， 增强型赋值运算符，类型转换与四舍五入
##### **1.3.1 /，//，，科学计数法**
运算符 <u>&nbsp;&nbsp;**/**&nbsp;&nbsp;</u>执行浮点除法并产生一个浮点数结果如：

```markdown
## print(1/2)  # 0.5
```
运算符 <u>&nbsp;&nbsp;**//**&nbsp;&nbsp;</u>执行整数除法并产生一个整数结果，任何小数部分都会被舍掉如：
```markdown
# print(1//2)  #0
```
为了针对任意数字a与b计算a<sup>b</sup>(a的b次幂),在python中编写a**b。
```markdown
# html写法
# a<sup>b</sup>
# 数学公式写法 
#  $$
#  a^b
#  $$ 
```
例如：

```python
print(2.3 ** 3.5)  # 18.45216910555504

print((-2.5) ** 2) # 6.25
```

**科学计数法：**

浮点型用于表示有小数点的数字，这些数字在内存中以科学计数法存储，当**123.456**被转换为科学计数法是**1.23456E+1**,它的小数点浮动到一个新的位置 所以叫做浮点型。
$$
1.23456 * 10^2 \Longleftrightarrow  1.23456E+2
$$

##### **1.3.2 %, 增强型赋值运算符，类型转换与四舍五入**
运算符 <u>&nbsp;&nbsp;**%**&nbsp;&nbsp;</u>是一个求余或取模运算的运算符,即求出除法后的余数**80%60=20**

取余是一个非常有用的运算逻辑如:

```
1:   判断一个数字的奇偶性    任何数%2为0则为偶数否则为1为奇数
2: 今天是周六,二十天后是星期几?   (6+20)%7=5所以是周五
```

**增强型赋值运算符：**

变量的当前值被使用、修改、然后重新赋值给同一变量的情况。

| 运算符 | 名称                         | 举例    | 等式       |
| ------ | ---------------------------- | ------- | ---------- |
| +=     | addition assignment          | i += 8  | i = i + 8  |
| -=     | Subtraction assignment       | i -= 8  | i = i - 8  |
| *=     | Multiplication assignment    | i *= 8  | i = i * 8  |
| /=     | float division assignment    | i /= 8  | i = i / 8  |
| //=    | interger division assignment | i //= 8 | i = i // 8 |
| %=     | Remainder assignment         | i %= 8  | i = i % 8  |
| **=    | Exponent assignment          | i **= 8 | i = i ** 8 |

**类型转换与四舍五入：**

- int(str)函数将符合整数的规定的字符串转换成int型的
- float(str)函数将符合浮点型的规定的字符串转换成float型的
- str(num)将整数、浮点型转换成字符串型的

```python
value = 5.6
print(int(value))
# 5
print(value)
# 5.6  只是转换并没有改变原有变量值
print(round(value))
# 6   四舍五入
print(value)
# 5.6   依旧没有改变值
print(int("34"))
# 34   可以将整数字符串转换成整数 只能是整数字符串 ，如若是int("3.4")将会出错，但是int("0034")无错
print(eval("3.4 + 1"))
# 4.4  比int函数更多功能但是 eval(0034)会报语法错误SyntaxError十进制整数不能以0作为开头除非本身是0
```

#### 1.4 各进制对应的函数及其表示

- 二进制binary：                bin()     0b / 0B
- 八进制octonary：           oct()      0o /  0O
- 十六进制hexadecimal： hex()    0x  / 0X

0b101 转换为八进制            oct(0b101)  

0o101  转换为十六进制        hex(0o101)

0x101   转换为二进制           bin(0x101)

**数字分隔符：**

避免输入数错数字可以使用  <u>&nbsp;&nbsp;**—**&nbsp;&nbsp;</u>下划线作为数字的分隔符，不影响数字本身的值

num = 12345678     等价于    num = 123_456_78  


#### 1.5 print()，键盘输入及格式化输出




### 2.容器型
可容纳多个元素的容器对象，

set、tuple、list、dict。

1. 集合、元组、列表和字典都是一个可以放置任意数据类型的集合，数据类型无需一致
2. 除了集合无序其他都是有序的(字典在3.7之后有序)
3. 元组是静态的，长度不可变对象，无法增加删减或者改变，其他都可增减更改。
4. 集合中不允许出现重复元素
5. 集合与字典本质上是一个哈希表(字典在3.7后支持索引)，字典的key和集合中的元素必须是不可变数据结构即可哈希的数据类型(数字类型(int,float,bool)字符串、元组和自定义类的对象)即集合中的元素不能包含列表与字典与集合。

```python
s = {1,3,5}	#set集合
tup = (1,3,5)	#tuple元组
lst = [1,3,5]	#list列表
dic = {'a':1, 'b':3, 'c':5}	#dict字典

```

#### 2.1 元组与列表

- 列表和元组是一个可以放置任意数据类型的有序集合

- 列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）

- 元组是静态的，长度大小固定，无法增加删减或者改变（immutable)

  特别地注意 元组中(10)返回的是整数，只有加了逗号后(10,)才会返回元组对象

##### 2.1.1**可以放置任意数据类型**

```python
class Empty:
    pass

l = [1,2.0,True,'wan颜',{3,4,5},(6,7),[8,9],{'a':10, 'b':11},Empty]
for _ in l:
    print(f'{_}的数据类型为{type(_)}')

# t = (1,2.0,True,'wan颜',{3,4,5},(6,7),[8,9],{'a':10, 'b':11},Empty)  同理


1的数据类型为<class 'int'>
2.0的数据类型为<class 'float'>
True的数据类型为<class 'bool'>
wan颜的数据类型为<class 'str'>
{3, 4, 5}的数据类型为<class 'set'>
(6, 7)的数据类型为<class 'tuple'>
[8, 9]的数据类型为<class 'list'>
{'a': 10, 'b': 11}的数据类型为<class 'dict'>
<class '__main__.Empty'>的数据类型为<class 'type'>
```

#####  2.1.2**元组列表有序、列表动态可增删改、元组静态、可变与不可变、深浅拷贝、列表与元组的转换、切片**

```python
（[1,'2',['苹果', 'apple','香蕉']]）
（ 0，1，    2）
（-3，-2，  -1）   #排序有序

lst = [1,'2',['苹果', 'apple','香蕉']]
lst2 = (1,'2',['苹果', 'apple','香蕉'])
print(lst[-2])                  #2
print(lst2[-2])					#2

sku = lst[2]
print(sku)						#['苹果', 'apple', '香蕉']   列表有序
sku.append('banana')
print(sku)						#['苹果', 'apple', '香蕉', 'banana']   列表动态可增
sku.insert(2,'狗')
print(sku)						#['苹果', 'apple', '狗', '香蕉', 'banana']  列表动态可插入
item = sku.pop()
print(sku)						#['苹果', 'apple', '狗', '香蕉']pop可索引默认删除最后一位
sku.remove('狗')
print(sku)						#['苹果', 'apple', '香蕉']   可任意删除
sku[-1] = '狗'
print(sku)						#['苹果', 'apple', '狗']   

tup = (1,2,3,4)
print(tup[-1])							#4    元组是有序的
tup[3] = 40				#TypeError: 'tuple' object does not support item assignment
						#元组是不可变的

```

**可变与不可变*

创建一个列表 a = [1,3,[5,7],9,11,13]     一个元组  b = (1,3,[5,7],9,11,13)

元组是静态的不可变的但是当     **b[2].insert(1,6)**   时print(b)输出  **(1, 3, [5, 6, 7], 9, 11, 13)**  元组的长度序号没有增加，但是内容增加了

当**a[2].insert(1,6)**  时也输出 **(1, 3, [5, 6, 7], 9, 11, 13)**  但是列表的长度也没变也是内容增加了，这不是真正调整a为可变的操作



**深浅拷贝**

```python
a = [1,2,[3,4,5]]
ac = a.copy()
ac[0] = 10
ac[2][1] = 40
print(a)			#[1, 2, [3, 40, 5]]
print(ac)			#[10, 2, [3, 40, 5]]
a[2][0] = 30
print(ac)			#[10, 2, [30, 40, 5]]
```

由上可以看出a列表里面嵌套的列表属于另一个内存空间   

即

```python
a = [1,2,[3,4,5]]
a_shallow = a[2].copy()
a_shallow[0] = 30
print(a)		#[1,2,[3,4,5]]
print(a_shallow)#[30, 4, 5]
```

**以上就是浅拷贝**

**以下就是深拷贝： **

```python
from copy import deepcopy

a = [1,2,[3,4,5]]
ac = deepcopy(a)
ac[0] = 10
ac[2][1] = 40
print(a)			#[1, 2, [3, 4, 5]]
print(ac)			#[10, 2, [3, 40, 5]]
```

对拷贝对象全部拷贝，一般都是浅拷贝如果遇到嵌套的一定要注意！！

**列表与元组的转换、切片**

1. 列表与元组的转换
```python
list((1,2,3))
[1,2,3]

tuple([1,2,3])
(1,2,3)
```

2. 切片
java和c++中，访问数组中的元素只能一次一个，但python增加切片功能为访问列表带来极大便利。利用内函数range(start,stop,step)生成序列数组，并转为list类型：
```python
a = list(range(1,20,3))
print(a)     #[1, 4, 7, 10, 13, 16, 19]
```

使用a[:3]获取列表a的前三个元素，形象称这类操作为"切片"，切片本身也是一个列表[1,4,7]:

- a[-1]       获取a里序列最后一个元素，返回int型，19

- a[:-1]      获取除了最后一个元素的切片[1,4,7,10,13,16]

- a[1:5]     生成索引为[1,5)(不包括索引5)的切片[4,7,10,13]

- a[1:5:2]  生成索引[1,5)但是步长为2的切片[4,10]

- a[::3]       生成索引[0,len(a)) 步长为3的切片[1,10,19]

- a[::-3]      生成逆向索引[len(a),0) 步长为3 的切片[19,10,1]

  注意：len(a)  为7 而索引为0:6  所以在[::]中是包括切片的所有索引对象的

特别地，使用列表的逆向切片操作，只需要一行代码就能逆向列表：

```python
def reverse(lst):
    return lst[::-1]
# 调用reverse函数：
ra = reverse(a)
print(ra)  # [19, 16, 13, 10, 7, 4, 1]

```

##### 2.1.3 列表与元组的存储与性能的差异

1. 存储

```python
l = [1,2,3]
l.__sizeof__()		#64
					#Size of object in memory, in bytes
tup = (1,2,3)
tup.__sizeof__()	#48

```

相同的元素元组的存储空间比列表少16字节：列表是动态的所以它需要存储指针来指向对应的元素，另由于列表可变，所以需要额外存储已经分配的长度大小，这样才可以实时追踪列表控件的使用情况，当空间不足时，及时分配额外空间。

```

l = []
l.__sizeof__() // 空列表的存储空间为40字节
40
l.append(1)
l.__sizeof__() 
72 // 加入了元素1之后，列表为其分配了可以存储4个元素的空间 (72 - 40)/8 = 4
l.append(2) 
l.__sizeof__()
72 // 由于之前分配了空间，所以加入元素2，列表空间不变
l.append(3)
l.__sizeof__() 
72 // 同上
l.append(4)
l.__sizeof__() 
72 // 同上
l.append(5)
l.__sizeof__() 
104 // 加入元素5之后，列表的空间不足，所以又额外分配了可以存储4个元素的空间
```

为了减小每次增加/删减操作时空间分配的开销，其每次分配空间时都会额外多分配一些，对于元组长度大小固定，元素不可变，所以存储空间固定。
2. 性能

python会在后台对静态数据做一些资源缓存(resource caching)。因为垃圾回收机制的存在，若一些变量不被使用其就会回收他们所占用的内存返还给操作系统，以便其他变量或其他应用使用。但是对于一些静态变量，如元组，如果它不被使用并且占用空间不大时，python会暂缓这部分内存，下次在创建同样大小的元组时，python就会不用再向操作系统发出请求，去寻找内存，而是直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。

如下是计算**初始化**一组相同元素的列表和元组分别所需的时间，得元组的初始化速度比列表快5倍。

```python
import timeit
t1 = timeit.Timer('x=[1,2,3,4,5,6]')
print(t1.timeit())
t2 = timeit.Timer('x=(1,2,3,4,5,6)')
print(t2.timeit())
#0.0638844
#0.0161684
```

在创建一个空列表时在效率上也是有区别的，如：

```python
empty_list = list()
empty_list = []
```

list()是一个function call,python的function call 会创建stack，并且进行一系列参数检查的操作，比较复杂，而[]是一个内置的c函数，可以直接被调用因此效率高，所以直接用[]创建空列表。

- 在存储数据和数量不变时，如一个函数返回一个固定值选择元组合适
- 在存储的数据或数量是可变的，如循环索引数据库返回存储则列表更合适

#### 2.2 字典和集合

- 集合与字典本质上是一个哈希表(字典在3.7后支持索引)，字典的key和集合中的元素必须是不可变数据结构即可哈希的数据类型(数字类型(int,float,bool)字符串、元组和自定义类的对象)即集合中的元素不能包含列表与字典与集合
- 集合中不允许出现重复元素
- 字典在python3.7+被确定为有序

##### 2.2.1哈希表

散列表(hash table，音译为哈希表)

哈希(hash散列),hash算法，是将一个不定长的输入，通过散列函数编程一个定长的输出，这种散列变换时一种单向运算，具有不可逆性即不能根据散列值还原出输入信息，因此hash算法是一种消息摘要算法，不是一种加密算法。

使用hash算法的数据结构叫做哈希表(散列表),通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，映射函数就是hash函数，存放记录的数组叫做哈希表。如手机联系人里，列表查询即一个一个去查找即通过整数[0, ∞ )作为索引存储值，散列表即是通过key关键词查找。自然会比列表查找快的多。

##### 2.2.2 字典(dict)

可哈希的对象才能作为字典的键，即数字类型(int,float,bool)字符串、元组和自定义类的对象。

创建字典：

```python
empty = {}
dic = {'a':1, 'c':3, 'e':5}

print(dict(a=1,b=2, c=3))

print(dict({'a' : 1, 'b' : 2}, c=3, d=4))

print(dict([('a',1), ('b',2)],c=3))

print({}.fromkeys(['k1', 'k2', 'k3'], [1,2,3]))
print({'a':1, 'b':2}.fromkeys(['c', 'd'],[1,2]))
```

字典有序不意味着可以序列查找,python3.6之前输出字典都是无序的混乱的

```python
p = dict(d=4,a=1,b=2, c=3)
for k,v in p.items():
    print(k,v)
d 4
a 1
b 2
c 3
```

字典的内置函数方法：


| 函数或方法                         | 作用                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| cmp(dict1, dict2)                  | 比较两个字典元素                                             |
| len(dict)                          | 字典长度                                                     |
| str(dict)                          | 输出字典可打印的字符串表示                                   |
| type(variable)                     | 输出变量的类型                                               |
| dict.clear()                       | 删除字典内所有元素                                           |
| dict.copy()                        | 返回字典的一个复制                                           |
| dict.fromkeys(seq[, val])          | 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 |
| dict.get(key, default=None)        | 返回指定键的值，如果值不在字典中返回default值                |
| dict.has_key(key)                  | 如果键在字典dict里返回true，否则返回false                    |
| dict.items()                       | 以列表返回可遍历的(键, 值) 元组数组                          |
| dict.keys()                        | 以列表返回一个字典所有的键                                   |
| dict.setdefault(key, default=None) | 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |
| dict.update(dict2)                 | 把字典dict2的键/值对更新到dict里                             |
| dict.values()                      | 以列表返回字典中的所有值                                     |
| pop(key[,default])                 | 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |
| popitem()                          | 随机返回并删除字典中的一对键和值。                           |

##### 2.2.3 集合

集合的对象与字典中的键值一样是可哈希的且不重复的，常常利用列表的不重复性质判断列表中是否含有重复元素

```python
def fuplicated(lst):
    return len(lst)!=len(set(lst))

print(set((1,2,3,4)))
a = {1,3,5,7}
b, c = {3,4,5,6}, {6,7,8,9}
print(a.union(b,c))   #求并集
print(a.difference(b,c))#求差集
print(a.intersection(b))#求交集
print(a.issubset({1,2,3,4,5,7}))#子集
```



##### 2.2.4  字典与集合哈希后的性能，有序与内存优化提升分析

以十万随机数据量分别存入列表与集合中，速度相差数千倍

```python
def find_unique_price_using_list(products):
    unique_price_list = []
    for _, price in products: # A
        if price not in unique_price_list: #B
            unique_price_list.append(price)
    return len(unique_price_list)
def find_unique_price_using_set(products):
    unique_price_set = set()
    for _, price in products:
        unique_price_set.add(price)
    return len(unique_price_set)

import time
id = [x for x in range(0, 100000)]
price = [x for x in range(200000, 300000)]
products = list(zip(id, price))

# 计算列表版本的时间
start_using_list = time.perf_counter()
find_unique_price_using_list(products)
end_using_list = time.perf_counter()
print("time elapse using list: {}".format(end_using_list - start_using_list))
## time elapse using list: 80.9745429

# 计算集合版本的时间
start_using_set = time.perf_counter()
find_unique_price_using_set(products)
end_using_set = time.perf_counter()
print("time elapse using set: {}".format(end_using_set - start_using_set))
# time elapse using set: 0.02666370000000029

```

1. 在py3.6之前

   ```
   my_dict = {}
    
   '''
   此时的内存示意图
   [[---, ---, ---],
   [---, ---, ---],
   [---, ---, ---],
   [---, ---, ---],
   [---, ---, ---],
   [---, ---, ---],
   [---, ---, ---],
   [---, ---, ---]]
   '''
   ```

然后，往字典里添加一个数据：

```
my_dict['name'] = 'kingname'
 
'''
此时的内存示意图
[[---, ---, ---],
[---, ---, ---],
[---, ---, ---],
[---, ---, ---],
[---, ---, ---],
[---, ---, ---],
[---, ---, ---]]，
[2303528788703091807, 指向name的指针, 指向kingname的指针]
'''
```

注意：python自带的hash函数只能保证在每一次运行时不变，当重新打开python 时它的值会变。

这里，hash('name')>>>2303528788703091807%8=7，所以位于8行0-7中的序列7行中。

- 开放寻址，当两个不同的Key，经过Hash以后，再对8取余数，可能余数会相同。此时Python为了不覆盖之前已有的值，就会使用开放寻址技术重新寻找一个新的位置存放这个新的键值对。

- 当字典的键值对数量超过当前数组长度的2/3时，数组会进行扩容，8行变成16行，16行变成32行。长度变了以后，原来的余数位置也会发生变化，此时就需要移动原来位置的数据，导致插入效率变低。

2. 在py3.6之后：

   ```
   my_dict = {}
    
   '''
   此时的内存示意图
   indices = [None, None, None, None, None, None, None, None]
    
   entries = []
   '''
   ```

   ```
   my_dict['address'] = 'xxx'
   my_dict['salary'] = 999999
    
   '''
   此时的内存示意图
   indices = [1, 0, None, None, None, None, 2, None]
    
   entries = [[-5954193068542476671, 指向name的指针, 执行kingname的指针],
        [9043074951938101872, 指向address的指针，指向xxx的指针],
        [7324055671294268046, 指向salary的指针, 指向999999的指针]
        ]
   '''
   ```

   读取salary的值，首先计算salary的hash值，以及这个值对于8的余数，余6

   然后读取indices下标6中得到2，即对应在entries中序列2中得到对应的value

   由上：

   - 即使有效数据占3行，在py3.6之前仍然占8行的数据量，在py3.6之后即只占用3行以及一个一维数组8byte
   - 虽然hash是混乱随机数，但是在entries中仍然是有序存储,所以之后就有序了

## 二、 函数













