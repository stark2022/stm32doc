[TOC]
# 数据结构与算法
## 一、复杂度分析
一种不用具体的测试数据来测试就可以**粗略地估计**算法的执行效率的方法，就是一种估计算法效率的简略宏观方法；通过统计、监控可以精确得到算法执行的时间和占用内存的大小。但是在编写程序的时候需要先大致估算算法效率然后尽可能地优化。
### 渐进时间复杂度（asymptotic tie complexity)简称时间复杂度
以时间为对象进行粗略地估算
```c
int cal(int n) {
	int sum = 0;
	int i = 1;
	for (; i <= n; ++i) {
		sum = sum + i;
	}
	return sum;
}
```
假设每行代码执行的时间都一样，为 unit_time  所有代码的执行时间为 T(n) 。第 2、 3 行代码分别都需要 1 个 unit_time 的执行时间，第 4、 5 行都运行了 n 遍，所以需要 2n * unit_time 的执行时间，所以这段代码总的执行时间就是 （2n+2) * unit_time 。观察可知 代码的执行时间 T(n) 与每行代码的执行次数成正比 。

```c
int cal(int n) {
	int sum = 0;
	int i = 1;
	int j = 1;
	for (; i <= n; ++i) {
		j = 1;
		for (; j <= n; ++j) {
			sum = sum + i * j;
		}
	}
}
```
同上，第 2、 3、 4 行代码每行都需要 1 个 unit_time 的执行时间， 第 5、 6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间， 第 7、 8 行代码循环执行了 n<sup>2</sup> 遍，所以需要 2n<sup>2</sup> * unit_time 的执行时间。所以整段代码总的执行时间 T(n) = (2n<sup>2</sup> + 2n + 3) * unit_time 。
**我们把这样的规律总结成一个公式**
$$
T(n) = O(f(n))
$$
T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为是一个公式所以用f(n)来表示。公式中的 O，表示代码的执行时间T(n) 与 f(n) 表达式成正比。
所以，第一个例子中的 T(n) = O(2n + 2)，第二个例子中的 T(n) = O(2n<sup>2</sup> + 2n + 3) 。这就是**大 O 时间复杂度表示法**。其并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势** ，所以叫做**渐进时间复杂度** ，简称**时间复杂度** 。

 ### 时间复杂度分析
#### 1.只关注循环执行次数最多的一段代码

大 O 这种复杂度表示方法只是表示一种变化趋势，我们通常会忽略公式中的常量、低阶、系数，只需记录一个最大阶的量级就可以了。还是之前的例子

```c
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

第 2、 3 行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、 5 行代码，所以这块代码要重点分析。这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。

#### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度

```c
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```

代码分为三部分，第一段的时间复杂度是 O(1) ，代码循环100次与循环 100000 次都是一个常量的执行时间是有限的常量的，当 n 无限大的时候就可以忽略，尽管对代码的执行时间会有很大影响，但是它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量多大都可以忽略，因为它本身对增长趋势没有影响。

第二段代码是 O(n) 第三段是 O(n<sup>2</sup>) 。综合三段代码的时间复杂度，取其中最大的量级，整段代码的时间复杂度就是 O(n<sup>2</sup>)。即：**总的时间复杂度就等于量级最大的那段代码的时间复杂度** 。

#### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

```c
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

若T1(n) = O(n) , T2(n) = O(n<sup>2</sup>)，则T1(n) * T2(n) = O(n<sup>3</sup>) 。通常把乘法法则看成是**嵌套循环** 

### 常见时间复杂度实例分析

- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n<sup>2</sup>)   、立方阶 O(n<sup>3</sup>) 、、、、k次方阶O(n<sup>k</sup>)
- 
- 指数阶 O(2<sup>n</sup>)
- 阶乘阶 O(n!)

粗略地分为两类，**多项式量级** 和 **非多项式量级** 。其中非多项式量级只有两个： O(2<sup>n</sup>) 和 O(n!)。

非多项式量级的算法问题叫作 **NP** (Non-Deterministic Polynomial，非确定多项式) 问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长，所以非多项式时间复杂度的算法其实是非常低效的算法，因此关于 **NP** 时间复杂度不常见。

#### 1.O(1)

O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。即便有一万行十万行，其时间复杂度也是 O(1)。

```
 int i = 8;
 int j = 6;
 int sum = i + j;
```

只要代码的执行时间不随 n 的增大而增长，其时间复杂度都记作 O(1)。**一般情况下，只要算法中不存在循环语句、递归语句，即使有上万行代码，其时间复杂度也是 O(1)。

#### 2. O(logn)、O(nlogn)

```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

变量 i 的值从 1 开始取，循环一次 i 为 2；循环第二次 i 为 2*2即 2<sup>2</sup> ;循环第三次 i 为 2<sup>3</sup>

 以此类推 是一个等比数列 ，循环到第x次 <= n 即 2<sup>x</sup> = n ； x = $log_2 n $

这段代码的时间复杂度就是O($log_2 n$) 。

```
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
```

这段代码的时间复杂度就是O($log_3 n$) 
实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，通常把所有对数阶的时间复杂度都记为O(logn)

$log_3n$  = $log_3 2$   * $log_2 n$  所以O($log_3 n$) = O(C * $log_2 n$)，其中 C = $log_3 2$ 是一个常量可以忽略。所以，O($log_2 n$) 就等于 O($log_3 n)。所以对于对数阶的时间复杂度都统一表示为 O(logn)。

如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn)。

#### 3. O(m+n)、O(m*n)

```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

代码中 m 和 n 是表示两个数据规模，无法评估 m 和 n 谁的量级大，所以就**不能**简单地利用加法法则省略其中一个，所以上面代码的时间复杂度就是 O(m +n)。

乘法法则依然有效即一段代码的时间复杂度是 O(n)，循环执行了 m 遍，其复杂度就是 O(m*n)

### 渐进空间复杂度(asymptotic space complexity) 简称空间复杂度

表示算法的存储空间与数据规模之间增长关系

```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

第2行中申请了一个空间存储变量 i ，是常量阶可以忽略，第3行申请了一个为 n 的 int 类型数组，除此之外其他代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)

常见的空间复杂度只有 O(1)、 O(n)、O(n<sup>2</sup>)。

### 最好、最坏情况时间复杂度
```c
int find(int[] array, int n, int x){
	int i = 0;
	int pos = -1;
	for (; i < n; ++i){
		if (array[i] == x) pos = i;
	}
	return pos;
}
```

代码的功能是，在一个无序数组(array)中，查找到与设定值 x 对应的数组序号，如果没有找到按照第三行的设定将返回 -1。按照之前的分析方法，这段代码的复杂度是 O(n)

我们在数组中查找一个数据并不需要每次都把整个数组都遍历一遍，如果中途找到就可以提前结束循环了。

```
int find(int[] array, int n, int x){
	int i = 0;
	int pos = -1;
	for (; i < n; ++i) {
		if (array[i] == x){
			pos = i;
			break;
		}
	}
	return pos;
}
```

在循环里加了一个 break 优化完之后，这段代码的时间复杂度是O(n)还是O(1)? 如果数组中存在与 x 对应的数值那么时间复杂度就是 O(1) 如果不存在就是 O(n)。所以在不同情况下，这段代码的时间复杂度是不一样的。

顾名思义 最好情况时间复杂度就是，在理想的情况下，执行这段代码的时间复杂度，最坏就是在最糟糕的情况下，执行这段代码的时间复杂度。

### 平均情况时间复杂度

最好和最坏时间复杂度对应的都是极端情况下的代码复杂度，所以就有平均情况时间复杂度，沿用上面的例子

在查找的变量 x 在数组中的位置，有 n+1种情况：在数组的 0~ n-1 位置中和不在数组中。把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1,就可以得到需要遍历的元素个数的平均值，即：
$$
\frac{1+2+3+ \cdots +n +n }{n+1}= \frac{n(n+3)}{2(n+1)}
$$
简化公式后得到的平均时间复杂度就是O(n)。上面的列子没有考虑每种情况出现的具体概率，查找的变量 x ，要么在数组里，要么就不在数组里，假设在数组中与不在数组中的概率都为 1/2 。另外数据出现在 0~ n-1 这n 个位置的概率也是一样的1/n 。所以出现在 0 ~ n-1中任意位置的概率就是 1/(2n)。把每种情况发生的概率也考虑进去，计算就为：
$$
1 *\frac {1}{2n}+2*\frac {1}{2n}+3*\frac {1}{2n}+\cdots +n*\frac {1}{2n}+n*\frac {1}{2}=\frac {3n+1}{4}
$$
化简后也是O(n)

只有同一块代码在不同的情况下，时间复杂度有量级的差距时才会使用这三种复杂度表示法来区分。

### 均摊时间复杂度

